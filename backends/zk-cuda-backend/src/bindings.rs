/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type cudaStream_t = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct Fp {
    pub limb: [u64; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Fp"][::std::mem::size_of::<Fp>() - 56usize];
    ["Alignment of Fp"][::std::mem::align_of::<Fp>() - 8usize];
    ["Offset of field: Fp::limb"][::std::mem::offset_of!(Fp, limb) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct Fp2 {
    pub c0: Fp,
    pub c1: Fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Fp2"][::std::mem::size_of::<Fp2>() - 112usize];
    ["Alignment of Fp2"][::std::mem::align_of::<Fp2>() - 8usize];
    ["Offset of field: Fp2::c0"][::std::mem::offset_of!(Fp2, c0) - 0usize];
    ["Offset of field: Fp2::c1"][::std::mem::offset_of!(Fp2, c1) - 56usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct BigInt {
    pub limb: [u64; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BigInt"][::std::mem::size_of::<BigInt>() - 40usize];
    ["Alignment of BigInt"][::std::mem::align_of::<BigInt>() - 8usize];
    ["Offset of field: BigInt::limb"][::std::mem::offset_of!(BigInt, limb) - 0usize];
};
pub type Scalar = BigInt;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct G1Point {
    pub x: Fp,
    pub y: Fp,
    pub infinity: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of G1Point"][::std::mem::size_of::<G1Point>() - 120usize];
    ["Alignment of G1Point"][::std::mem::align_of::<G1Point>() - 8usize];
    ["Offset of field: G1Point::x"][::std::mem::offset_of!(G1Point, x) - 0usize];
    ["Offset of field: G1Point::y"][::std::mem::offset_of!(G1Point, y) - 56usize];
    ["Offset of field: G1Point::infinity"][::std::mem::offset_of!(G1Point, infinity) - 112usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct G2Point {
    pub x: Fp2,
    pub y: Fp2,
    pub infinity: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of G2Point"][::std::mem::size_of::<G2Point>() - 232usize];
    ["Alignment of G2Point"][::std::mem::align_of::<G2Point>() - 8usize];
    ["Offset of field: G2Point::x"][::std::mem::offset_of!(G2Point, x) - 0usize];
    ["Offset of field: G2Point::y"][::std::mem::offset_of!(G2Point, y) - 112usize];
    ["Offset of field: G2Point::infinity"][::std::mem::offset_of!(G2Point, infinity) - 224usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct G1ProjectivePoint {
    pub X: Fp,
    pub Y: Fp,
    pub Z: Fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of G1ProjectivePoint"][::std::mem::size_of::<G1ProjectivePoint>() - 168usize];
    ["Alignment of G1ProjectivePoint"][::std::mem::align_of::<G1ProjectivePoint>() - 8usize];
    ["Offset of field: G1ProjectivePoint::X"]
        [::std::mem::offset_of!(G1ProjectivePoint, X) - 0usize];
    ["Offset of field: G1ProjectivePoint::Y"]
        [::std::mem::offset_of!(G1ProjectivePoint, Y) - 56usize];
    ["Offset of field: G1ProjectivePoint::Z"]
        [::std::mem::offset_of!(G1ProjectivePoint, Z) - 112usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct G2ProjectivePoint {
    pub X: Fp2,
    pub Y: Fp2,
    pub Z: Fp2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of G2ProjectivePoint"][::std::mem::size_of::<G2ProjectivePoint>() - 336usize];
    ["Alignment of G2ProjectivePoint"][::std::mem::align_of::<G2ProjectivePoint>() - 8usize];
    ["Offset of field: G2ProjectivePoint::X"]
        [::std::mem::offset_of!(G2ProjectivePoint, X) - 0usize];
    ["Offset of field: G2ProjectivePoint::Y"]
        [::std::mem::offset_of!(G2ProjectivePoint, Y) - 112usize];
    ["Offset of field: G2ProjectivePoint::Z"]
        [::std::mem::offset_of!(G2ProjectivePoint, Z) - 224usize];
};
unsafe extern "C" {
    pub fn affine_to_projective_g1_wrapper(proj: *mut G1ProjectivePoint, affine: *const G1Point);
}
unsafe extern "C" {
    pub fn affine_to_projective_g2_wrapper(proj: *mut G2ProjectivePoint, affine: *const G2Point);
}
unsafe extern "C" {
    pub fn projective_to_affine_g1_wrapper(affine: *mut G1Point, proj: *const G1ProjectivePoint);
}
unsafe extern "C" {
    pub fn projective_to_affine_g2_wrapper(affine: *mut G2Point, proj: *const G2ProjectivePoint);
}
unsafe extern "C" {
    pub fn g1_point_at_infinity_wrapper(point: *mut G1Point);
}
unsafe extern "C" {
    pub fn g2_point_at_infinity_wrapper(point: *mut G2Point);
}
unsafe extern "C" {
    pub fn g1_projective_point_at_infinity_wrapper(point: *mut G1ProjectivePoint);
}
unsafe extern "C" {
    pub fn g2_projective_point_at_infinity_wrapper(point: *mut G2ProjectivePoint);
}
unsafe extern "C" {
    pub fn g1_is_infinity_wrapper(point: *const G1Point) -> bool;
}
unsafe extern "C" {
    pub fn g2_is_infinity_wrapper(point: *const G2Point) -> bool;
}
unsafe extern "C" {
    pub fn g1_msm_unmanaged_wrapper_async(
        stream: cudaStream_t,
        gpu_index: u32,
        h_result: *mut G1ProjectivePoint,
        d_points: *const G1Point,
        d_scalars: *const Scalar,
        n: u32,
        d_scratch: *mut G1ProjectivePoint,
        gpu_memory_allocated: bool,
        size_tracker: *mut u64,
    );
}
unsafe extern "C" {
    pub fn g2_msm_unmanaged_wrapper_async(
        stream: cudaStream_t,
        gpu_index: u32,
        h_result: *mut G2ProjectivePoint,
        d_points: *const G2Point,
        d_scalars: *const Scalar,
        n: u32,
        d_scratch: *mut G2ProjectivePoint,
        gpu_memory_allocated: bool,
        size_tracker: *mut u64,
    );
}
unsafe extern "C" {
    pub fn pippenger_scratch_size_g1_wrapper(n: u32, gpu_index: u32) -> usize;
}
unsafe extern "C" {
    pub fn pippenger_scratch_size_g2_wrapper(n: u32, gpu_index: u32) -> usize;
}
unsafe extern "C" {
    pub fn g1_msm_managed_wrapper(
        stream: cudaStream_t,
        gpu_index: u32,
        result: *mut G1ProjectivePoint,
        points: *const G1Point,
        scalars: *const Scalar,
        n: u32,
        points_in_montgomery: bool,
        size_tracker: *mut u64,
    );
}
unsafe extern "C" {
    pub fn g2_msm_managed_wrapper(
        stream: cudaStream_t,
        gpu_index: u32,
        result: *mut G2ProjectivePoint,
        points: *const G2Point,
        scalars: *const Scalar,
        n: u32,
        points_in_montgomery: bool,
        size_tracker: *mut u64,
    );
}
unsafe extern "C" {
    pub fn g1_from_montgomery_wrapper(result: *mut G1Point, point: *const G1Point);
}
unsafe extern "C" {
    pub fn g2_from_montgomery_wrapper(result: *mut G2Point, point: *const G2Point);
}
unsafe extern "C" {
    pub fn fp_to_montgomery_wrapper(result: *mut Fp, value: *const Fp);
}
unsafe extern "C" {
    pub fn fp_from_montgomery_wrapper(result: *mut Fp, value: *const Fp);
}
unsafe extern "C" {
    pub fn g1_projective_from_montgomery_normalized_wrapper(
        result: *mut G1ProjectivePoint,
        point: *const G1ProjectivePoint,
    );
}
unsafe extern "C" {
    pub fn g2_projective_from_montgomery_normalized_wrapper(
        result: *mut G2ProjectivePoint,
        point: *const G2ProjectivePoint,
    );
}
unsafe extern "C" {
    pub fn is_on_curve_g1_wrapper(point: *const G1Point) -> bool;
}
unsafe extern "C" {
    pub fn is_on_curve_g2_wrapper(point: *const G2Point) -> bool;
}
unsafe extern "C" {
    pub fn scalar_modulus_limbs_wrapper(limbs: *mut u64);
}
