//! Rust wrapper types for BLS12-446 curve elements
//!
//! This module provides safe Rust wrappers around the FFI types generated by bindgen,
//! organized by curve group:
//! - [`g1`]: G1 affine and projective points
//! - [`g2`]: G2 affine and projective points
//! - [`scalar`]: 320-bit scalar field elements

mod g1;
mod g2;
mod scalar;

pub use g1::*;
pub use g2::*;
pub use scalar::*;

use crate::bindings::{Fp, Fp2, G1Point, G2Point};

impl G1Point {
    /// Create the affine identity element (point at infinity).
    #[allow(dead_code)]
    pub(crate) fn infinity() -> Self {
        Self {
            x: Fp::default(),
            y: Fp::default(),
            infinity: true,
        }
    }
}

impl G2Point {
    /// Create the affine identity element (point at infinity).
    #[allow(dead_code)]
    pub(crate) fn infinity() -> Self {
        Self {
            x: Fp2::default(),
            y: Fp2::default(),
            infinity: true,
        }
    }
}

/// Number of 64-bit limbs in a BLS12-446 base field element (Fp).
/// BLS12-446 has a 446-bit prime, requiring ceil(446/64) = 7 limbs.
pub const FP_LIMBS: usize = 7;

/// Number of 64-bit limbs in a BLS12-446 scalar field element.
/// BLS12-446 has a ~320-bit scalar field, requiring ceil(320/64) = 5 limbs.
pub const SCALAR_LIMBS: usize = 5;

// Custom Rust implementations for the bindgen-generated Fp type.
// These provide convenient constructors and conversion methods.

impl Fp {
    /// Create a new Fp from limbs (in normal form - must convert to Montgomery for computation)
    pub fn new(limbs: [u64; FP_LIMBS]) -> Self {
        Self { limb: limbs }
    }

    /// Create a new Fp from a BigInt-like structure (in normal form)
    /// This is a convenience method for compatibility with tfhe-zk-pok's BigInt<7>
    pub fn from_bigint(bigint: &[u64; FP_LIMBS]) -> Self {
        Self { limb: *bigint }
    }
}

/// Convert an Fp value to a decimal string.
/// Assumes the value is in normal form (not Montgomery).
pub(crate) fn fp_to_decimal_string(fp: &Fp) -> String {
    if fp.limb.iter().all(|&x| x == 0) {
        return "0".to_string();
    }

    let mut working = fp.limb;
    let mut digits = Vec::new();

    // Extract digits via repeated division by 10 (least-significant digit first)
    while !working.iter().all(|&x| x == 0) {
        let mut remainder = 0u64;
        for i in (0..working.len()).rev() {
            let value = ((remainder as u128) << 64) | (working[i] as u128);
            working[i] = (value / 10) as u64;
            remainder = (value % 10) as u64;
        }
        digits.push(b'0' + remainder as u8);
    }

    if digits.is_empty() {
        "0".to_string()
    } else {
        digits.reverse();
        String::from_utf8(digits).expect("digits are ASCII '0'-'9'")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bindings::Fp2;

    // BLS12-446 G1 generator coordinates (normal form, 64-bit limbs)
    const G1_GENERATOR_X: [u64; 7] = [
        0x3bf9166c8236f4fa,
        0x8bc02b7cbe6a9e8d,
        0x11c1e56b3e4bc80b,
        0x6b20d782901a6f62,
        0x2ce8c34265bf3841,
        0x11b73d3d76ae9851,
        0x326ed6bd777fc6a3,
    ];
    const G1_GENERATOR_Y: [u64; 7] = [
        0xfe6f792612016b30,
        0x22db0ce6034a9db9,
        0xb9093f32002756da,
        0x39d7f424b6660204,
        0xf843c947aa57f571,
        0xd6d62d244e413636,
        0x1a7caf4a4d3887a6,
    ];

    // BLS12-446 G2 generator coordinates (normal form, Fp2 = c0 + c1*u)
    const G2_GENERATOR_X_C0: [u64; 7] = [
        0x0e529ee4dce9991d,
        0xd6ebaf149094f1cc,
        0x043c6bf16312d638,
        0x062b61439640e885,
        0x18dad8ed784dd225,
        0xa57c0038441f7d15,
        0x21f8d4a76f74541a,
    ];
    const G2_GENERATOR_X_C1: [u64; 7] = [
        0xcaf5185423a7d23a,
        0x7cef6acb145b6413,
        0x2879dd439b019b8b,
        0x71449cdeca4f0007,
        0xdebaf4a2c5534527,
        0xa1b4e791d1b86560,
        0x1e0f563c601bb8dc,
    ];
    const G2_GENERATOR_Y_C0: [u64; 7] = [
        0x274315837455b919,
        0x82039e4221ff3507,
        0x00346cebad16a036,
        0x0177bfd6654e681e,
        0xddff621b5db3f897,
        0x0cc61570301497a7,
        0x115ea2305a78f646,
    ];
    const G2_GENERATOR_Y_C1: [u64; 7] = [
        0x392236e9cf2976c2,
        0xd8ab17c84b9f03cd,
        0x8a8e6755f9d82fd1,
        0x7532834528cd5a64,
        0x0b0bcc3fb6f2161c,
        0x76a2ffcb7d47679d,
        0x25ed2192b203c1fe,
    ];

    #[test]
    fn g1_infinity_is_at_infinity() {
        assert!(G1Affine::infinity().is_infinity());
    }

    #[test]
    fn g2_infinity_is_at_infinity() {
        assert!(G2Affine::infinity().is_infinity());
    }

    #[test]
    fn g1_projective_infinity_to_affine_is_infinity() {
        assert!(G1Projective::infinity().to_affine().is_infinity());
    }

    #[test]
    fn g2_projective_infinity_to_affine_is_infinity() {
        assert!(G2Projective::infinity().to_affine().is_infinity());
    }

    #[test]
    fn g1_msm_empty_returns_infinity() {
        let (result, _) = G1Projective::msm(&[], &[], std::ptr::null_mut(), 0, false).unwrap();
        assert!(result.to_affine().is_infinity());
    }

    #[test]
    fn g2_msm_empty_returns_infinity() {
        let (result, _) = G2Projective::msm(&[], &[], std::ptr::null_mut(), 0, false).unwrap();
        assert!(result.to_affine().is_infinity());
    }

    #[test]
    fn g1_msm_one_times_generator() {
        let gen = G1Affine::new(Fp::new(G1_GENERATOR_X), Fp::new(G1_GENERATOR_Y), false);
        let one = Scalar::from_u64(1);

        let stream = unsafe { tfhe_cuda_backend::cuda_bind::cuda_create_stream(0) };
        let (result, _) = G1Projective::msm(&[gen], &[one], stream, 0, false).unwrap();
        unsafe { tfhe_cuda_backend::cuda_bind::cuda_destroy_stream(stream, 0) };

        // from_montgomery_normalized() normalizes (divides by Z in Montgomery form)
        // then converts X, Y to normal form and sets Z = 1 (normal). The resulting
        // X, Y are already the affine coordinates in normal form.
        let normalized = result.from_montgomery_normalized();
        let affine_result = G1Affine::new(normalized.X(), normalized.Y(), false);
        assert_eq!(affine_result, gen);
    }

    #[test]
    fn g2_msm_one_times_generator() {
        let x = Fp2 {
            c0: Fp::new(G2_GENERATOR_X_C0),
            c1: Fp::new(G2_GENERATOR_X_C1),
        };
        let y = Fp2 {
            c0: Fp::new(G2_GENERATOR_Y_C0),
            c1: Fp::new(G2_GENERATOR_Y_C1),
        };
        let gen = G2Affine::new(x, y, false);
        let one = Scalar::from_u64(1);

        let stream = unsafe { tfhe_cuda_backend::cuda_bind::cuda_create_stream(0) };
        let (result, _) = G2Projective::msm(&[gen], &[one], stream, 0, false).unwrap();
        unsafe { tfhe_cuda_backend::cuda_bind::cuda_destroy_stream(stream, 0) };

        // Same approach: extract affine coordinates directly from normalized projective
        let normalized = result.from_montgomery_normalized();
        let affine_result = G2Affine::new(normalized.X(), normalized.Y(), false);
        assert_eq!(affine_result, gen);
    }
}
