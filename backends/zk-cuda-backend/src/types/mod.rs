//! Rust wrapper types for BLS12-446 curve elements
//!
//! This module provides safe Rust wrappers around the FFI types generated by bindgen,
//! organized by curve group:
//! - [`g1`]: G1 affine and projective points
//! - [`g2`]: G2 affine and projective points
//! - [`scalar`]: 320-bit scalar field elements

mod g1;
mod g2;
mod scalar;

pub use g1::*;
pub use g2::*;
pub use scalar::*;

use crate::bindings::Fp;

// Custom Rust implementations for the bindgen-generated Fp type.
// These provide convenient constructors and conversion methods.

impl Fp {
    /// Create a new Fp from limbs (in normal form - must convert to Montgomery for computation)
    pub fn new(limbs: [u64; 7]) -> Self {
        Self { limb: limbs }
    }

    /// Create a new Fp from a BigInt-like structure (in normal form)
    /// This is a convenience method for compatibility with tfhe-zk-pok's BigInt<7>
    pub fn from_bigint<const N: usize>(bigint: &[u64; N]) -> Self {
        const { assert!(N == 7, "from_bigint requires exactly FP_LIMBS (7) limbs") };
        let mut limbs = [0u64; 7];
        limbs.copy_from_slice(bigint.as_slice());
        Self { limb: limbs }
    }
}

/// Convert an Fp value to a decimal string.
/// Assumes the value is in normal form (not Montgomery).
pub(crate) fn fp_to_decimal_string(fp: &Fp) -> String {
    if fp.limb.iter().all(|&x| x == 0) {
        return "0".to_string();
    }

    let mut working = fp.limb;
    let mut result = String::new();

    while !working.iter().all(|&x| x == 0) {
        let mut remainder = 0u64;
        for i in (0..working.len()).rev() {
            let value = ((remainder as u128) << 64) | (working[i] as u128);
            working[i] = (value / 10) as u64;
            remainder = (value % 10) as u64;
        }
        result = format!("{}{}", remainder, result);
    }

    if result.is_empty() {
        "0".to_string()
    } else {
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Verify that the default initialization produces a point at infinity

    #[test]
    fn g1_projective_default_is_infinity() {
        assert_eq!(G1Projective::default(), G1Projective::infinity());
    }

    #[test]
    fn g2_projective_default_is_infinity() {
        assert_eq!(G2Projective::default(), G2Projective::infinity());
    }
}
