//! Module with the definition of the WopbsKey (WithOut padding PBS Key).
//!
//! This module implements the generation of another server public key, which allows to compute
//! an alternative version of the programmable bootstrapping. This does not require the use of a
//! bit of padding.
//!
//! In the case where a padding bit is defined, keys are generated so that there a compatible for
//! both uses.

use crate::core_crypto::algorithms::*;
use crate::core_crypto::commons::parameters::*;
pub use crate::core_crypto::commons::parameters::{CiphertextCount, PlaintextCount};
use crate::core_crypto::commons::traits::*;
use crate::core_crypto::entities::*;
use crate::core_crypto::fft_impl::fft64::math::fft::Fft;
use crate::shortint::ciphertext::*;
use crate::shortint::engine::ShortintEngine;
use crate::shortint::server_key::ShortintBootstrappingKey;
use crate::shortint::{Ciphertext, ClientKey, ServerKey, WopbsParameters};
use serde::{Deserialize, Serialize};

#[derive(Debug)]
pub enum WopbsKeyCreationError {
    UnsupportedMultiBit,
}

impl std::error::Error for WopbsKeyCreationError {}

impl std::fmt::Display for WopbsKeyCreationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UnsupportedMultiBit => {
                write!(f, "WopbsKey does not yet support using multi bit PBS")
            }
        }
    }
}

#[cfg(test)]
mod test;

// Struct for WoPBS based on the private functional packing keyswitch.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct WopbsKey {
    //Key for the private functional keyswitch
    pub wopbs_server_key: ServerKey,
    pub pbs_server_key: ServerKey,
    pub cbs_pfpksk: LwePrivateFunctionalPackingKeyswitchKeyListOwned<u64>,
    pub ksk_pbs_to_wopbs: LweKeyswitchKeyOwned<u64>,
    pub param: WopbsParameters,
}

#[must_use]
pub struct WopbsLUTBase {
    // Flattened Wopbs LUT
    plaintext_list: Vec<u64>,
    // How many output ciphertexts will be produced after applying the Wopbs to an input vector of
    // ciphertexts encrypting bits
    output_ciphertext_count: CiphertextCount,
}

impl WopbsLUTBase {
    pub fn from_vec(value: Vec<u64>, output_ciphertext_count: CiphertextCount) -> Self {
        Self {
            plaintext_list: value,
            output_ciphertext_count,
        }
    }

    pub fn new(small_lut_size: PlaintextCount, output_ciphertext_count: CiphertextCount) -> Self {
        Self {
            plaintext_list: vec![0; small_lut_size.0 * output_ciphertext_count.0],
            output_ciphertext_count,
        }
    }

    pub fn lut(&self) -> PlaintextListView<'_, u64> {
        PlaintextList::from_container(&self.plaintext_list)
    }

    pub fn lut_mut(&mut self) -> PlaintextListMutView<'_, u64> {
        PlaintextList::from_container(&mut self.plaintext_list)
    }

    pub fn output_ciphertext_count(&self) -> CiphertextCount {
        self.output_ciphertext_count
    }

    pub fn small_lut_size(&self) -> PlaintextCount {
        PlaintextCount(self.lut().plaintext_count().0 / self.output_ciphertext_count().0)
    }

    pub fn get_small_lut(&self, index: usize) -> &[u64] {
        assert!(
            index < self.output_ciphertext_count().0,
            "index {index} out of bounds, max {}",
            self.output_ciphertext_count().0
        );

        let small_lut_size = self.small_lut_size().0;

        &self.plaintext_list[index * small_lut_size..(index + 1) * small_lut_size]
    }

    pub fn get_small_lut_mut(&mut self, index: usize) -> &mut [u64] {
        assert!(
            index < self.output_ciphertext_count().0,
            "index {index} out of bounds, max {}",
            self.output_ciphertext_count().0
        );

        let small_lut_size = self.small_lut_size().0;

        &mut self.plaintext_list[index * small_lut_size..(index + 1) * small_lut_size]
    }
}

impl AsRef<[u64]> for WopbsLUTBase {
    fn as_ref(&self) -> &[u64] {
        self.plaintext_list.as_ref()
    }
}

impl AsMut<[u64]> for WopbsLUTBase {
    fn as_mut(&mut self) -> &mut [u64] {
        self.plaintext_list.as_mut()
    }
}

#[must_use]
pub struct ShortintWopbsLUT {
    inner: WopbsLUTBase,
}

impl ShortintWopbsLUT {
    pub fn new(lut_size: PlaintextCount) -> Self {
        Self {
            inner: WopbsLUTBase::new(lut_size, CiphertextCount(1)),
        }
    }

    pub fn iter(&self) -> std::slice::Iter<'_, u64> {
        self.inner.as_ref().iter()
    }

    pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, u64> {
        self.inner.as_mut().iter_mut()
    }
}

impl<'a> IntoIterator for &'a ShortintWopbsLUT {
    type IntoIter = std::slice::Iter<'a, u64>;
    type Item = &'a u64;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a> IntoIterator for &'a mut ShortintWopbsLUT {
    type IntoIter = std::slice::IterMut<'a, u64>;
    type Item = &'a mut u64;
    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl AsRef<WopbsLUTBase> for ShortintWopbsLUT {
    fn as_ref(&self) -> &WopbsLUTBase {
        &self.inner
    }
}

impl AsMut<WopbsLUTBase> for ShortintWopbsLUT {
    fn as_mut(&mut self) -> &mut WopbsLUTBase {
        &mut self.inner
    }
}

impl std::ops::Index<usize> for ShortintWopbsLUT {
    type Output = u64;

    fn index(&self, index: usize) -> &Self::Output {
        &self.inner.as_ref()[index]
    }
}

impl std::ops::IndexMut<usize> for ShortintWopbsLUT {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.inner.as_mut()[index]
    }
}

impl TryFrom<Vec<Vec<u64>>> for ShortintWopbsLUT {
    type Error = &'static str;

    fn try_from(mut value: Vec<Vec<u64>>) -> Result<Self, Self::Error> {
        if value.len() != 1 {
            return Err("ShortintWopbsLUT can only contain one small lut");
        }

        let value = value.remove(0);

        Ok(Self {
            inner: WopbsLUTBase::from_vec(value, CiphertextCount(1)),
        })
    }
}

impl From<Vec<u64>> for ShortintWopbsLUT {
    fn from(value: Vec<u64>) -> Self {
        Self {
            inner: WopbsLUTBase::from_vec(value, CiphertextCount(1)),
        }
    }
}

impl WopbsKey {
    /// Generate the server key required to compute a WoPBS from the client and the server keys.
    ///
    /// #Warning
    /// Only when the classical PBS is not used in the circuit
    ///
    /// # Example
    ///
    /// ```rust
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs_message_carry::WOPBS_PARAM_MESSAGE_1_CARRY_1_KS_PBS;
    /// use tfhe::shortint::parameters::PARAM_MESSAGE_1_CARRY_1_KS_PBS;
    /// use tfhe::shortint::wopbs::*;
    ///
    /// // Generate the client key and the server key:
    /// let (cks, sks) = gen_keys(WOPBS_PARAM_MESSAGE_1_CARRY_1_KS_PBS);
    /// let mut wopbs_key = WopbsKey::new_wopbs_key_only_for_wopbs(&cks, &sks);
    /// ```
    pub fn new_wopbs_key_only_for_wopbs(cks: &ClientKey, sks: &ServerKey) -> Self {
        ShortintEngine::with_thread_local_mut(|engine| {
            engine.new_wopbs_key_only_for_wopbs(cks, sks).unwrap()
        })
    }

    /// Generate the server key required to compute a WoPBS from the client and the server keys.
    /// # Example
    ///
    /// ```rust
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs_message_carry::WOPBS_PARAM_MESSAGE_1_CARRY_1_KS_PBS;
    /// use tfhe::shortint::parameters::PARAM_MESSAGE_1_CARRY_1_KS_PBS;
    /// use tfhe::shortint::wopbs::*;
    ///
    /// // Generate the client key and the server key:
    /// let (cks, sks) = gen_keys(PARAM_MESSAGE_1_CARRY_1_KS_PBS);
    /// let mut wopbs_key = WopbsKey::new_wopbs_key(&cks, &sks, &WOPBS_PARAM_MESSAGE_1_CARRY_1_KS_PBS);
    /// ```
    pub fn new_wopbs_key(cks: &ClientKey, sks: &ServerKey, parameters: &WopbsParameters) -> Self {
        ShortintEngine::with_thread_local_mut(|engine| engine.new_wopbs_key(cks, sks, parameters))
    }

    /// Generate the Look-Up Table homomorphically using the WoPBS approach.
    ///
    /// # Warning: this assumes one bit of padding.
    ///
    /// # Example
    ///
    /// ```rust
    /// use rand::Rng;
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs_message_carry::WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS;
    /// use tfhe::shortint::parameters::PARAM_MESSAGE_2_CARRY_2_KS_PBS;
    /// use tfhe::shortint::wopbs::*;
    ///
    /// // Generate the client key and the server key:
    /// let (cks, sks) = gen_keys(PARAM_MESSAGE_2_CARRY_2_KS_PBS);
    /// let mut wopbs_key = WopbsKey::new_wopbs_key(&cks, &sks, &WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS);
    /// let message_modulus = WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS.message_modulus.0 as u64;
    /// let m = 2;
    /// let mut ct = cks.encrypt(m);
    /// let lut = wopbs_key.generate_lut(&ct, |x| x * x % message_modulus);
    /// let ct_res = wopbs_key.programmable_bootstrapping(&sks, &mut ct, &lut);
    /// let res = cks.decrypt(&ct_res);
    /// assert_eq!(res, (m * m) % message_modulus);
    /// ```
    pub fn generate_lut<F>(&self, ct: &Ciphertext, f: F) -> ShortintWopbsLUT
    where
        F: Fn(u64) -> u64,
    {
        // The function is applied only on the message modulus bits
        let basis = ct.message_modulus.0 * ct.carry_modulus.0;
        let delta = 64 - f64::log2((basis) as f64).ceil() as u64 - 1;
        let poly_size = self.wopbs_server_key.bootstrapping_key.polynomial_size().0;
        let mut lut = ShortintWopbsLUT::new(PlaintextCount(poly_size));
        for (i, value) in lut.iter_mut().enumerate().take(basis) {
            *value = f((i % ct.message_modulus.0) as u64) << delta;
        }
        lut
    }

    /// Generate the Look-Up Table homomorphically using the WoPBS approach.
    ///
    /// # Warning: this assumes no bit of padding.
    ///
    /// # Example
    ///
    /// ```rust
    /// use rand::Rng;
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs_message_carry::WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS;
    /// use tfhe::shortint::wopbs::WopbsKey;
    ///
    /// // Generate the client key and the server key:
    /// let (cks, sks) = gen_keys(WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS);
    /// let mut wopbs_key = WopbsKey::new_wopbs_key_only_for_wopbs(&cks, &sks);
    /// let message_modulus = WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS.message_modulus.0 as u64;
    /// let m = 2;
    /// let ct = cks.encrypt_without_padding(m);
    /// let lut = wopbs_key.generate_lut(&ct, |x| x * x % message_modulus);
    /// let ct_res = wopbs_key.programmable_bootstrapping_without_padding(&ct, &lut);
    /// let res = cks.decrypt_without_padding(&ct_res);
    /// assert_eq!(res, (m * m) % message_modulus);
    /// ```
    pub fn generate_lut_without_padding<F>(&self, ct: &Ciphertext, f: F) -> Vec<u64>
    where
        F: Fn(u64) -> u64,
    {
        // The function is applied only on the message modulus bits
        let basis = ct.message_modulus.0 * ct.carry_modulus.0;
        let delta = 64 - f64::log2((basis) as f64).ceil() as u64;
        let poly_size = self.wopbs_server_key.bootstrapping_key.polynomial_size().0;
        let mut vec_lut = vec![0; poly_size];
        for (i, value) in vec_lut.iter_mut().enumerate().take(basis) {
            *value = f((i % ct.message_modulus.0) as u64) << delta;
        }
        vec_lut
    }

    /// Generate the Look-Up Table homomorphically using the WoPBS approach.
    ///
    ///
    /// # Example
    ///
    /// ```rust
    /// use rand::Rng;
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs_message_carry::WOPBS_PARAM_MESSAGE_3_CARRY_3_KS_PBS;
    /// use tfhe::shortint::wopbs::WopbsKey;
    ///
    /// // Generate the client key and the server key:
    /// let (cks, sks) = gen_keys(WOPBS_PARAM_MESSAGE_3_CARRY_3_KS_PBS);
    /// let wopbs_key = WopbsKey::new_wopbs_key_only_for_wopbs(&cks, &sks);
    /// let message_modulus = 5;
    /// let m = 2;
    /// let ct = cks.encrypt_native_crt(m, message_modulus);
    /// let lut = wopbs_key.generate_lut_native_crt(&ct, |x| x * x % message_modulus as u64);
    /// let ct_res = wopbs_key.programmable_bootstrapping_native_crt(&ct, &lut);
    /// let res = cks.decrypt_message_native_crt(&ct_res, message_modulus);
    /// assert_eq!(res, (m * m) % message_modulus as u64);
    /// ```
    pub fn generate_lut_native_crt<F>(&self, ct: &Ciphertext, f: F) -> ShortintWopbsLUT
    where
        F: Fn(u64) -> u64,
    {
        // The function is applied only on the message modulus bits
        let basis = ct.message_modulus.0 * ct.carry_modulus.0;
        let nb_bit = f64::log2((basis) as f64).ceil() as u64;
        let poly_size = self.wopbs_server_key.bootstrapping_key.polynomial_size().0;
        let mut lut = ShortintWopbsLUT::new(PlaintextCount(poly_size));
        for i in 0..basis {
            let index_lut = (((i as u64 % basis as u64) << nb_bit) / basis as u64) as usize;
            lut[index_lut] =
                (((f(i as u64) % basis as u64) as u128 * (1 << 64)) / basis as u128) as u64;
        }
        lut
    }

    /// Apply the Look-Up Table homomorphically using the WoPBS approach.
    ///
    /// #Warning: this assumes one bit of padding.
    ///
    /// # Example
    ///
    /// ```rust
    /// use rand::Rng;
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs_message_carry::WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS;
    /// use tfhe::shortint::parameters::PARAM_MESSAGE_2_CARRY_2_KS_PBS;
    /// use tfhe::shortint::wopbs::*;
    ///
    /// // Generate the client key and the server key:
    /// let (cks, sks) = gen_keys(PARAM_MESSAGE_2_CARRY_2_KS_PBS);
    /// let wopbs_key = WopbsKey::new_wopbs_key(&cks, &sks, &WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS);
    /// let mut rng = rand::thread_rng();
    /// let message_modulus = WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS.message_modulus.0;
    /// let ct = cks.encrypt(rng.gen::<u64>() % message_modulus as u64);
    /// let lut = vec![(1_u64 << 59); wopbs_key.param.polynomial_size.0].into();
    /// let ct_res = wopbs_key.programmable_bootstrapping(&sks, &ct, &lut);
    /// let res = cks.decrypt_message_and_carry(&ct_res);
    /// assert_eq!(res, 1);
    /// ```
    pub fn programmable_bootstrapping(
        &self,
        sks: &ServerKey,
        ct_in: &Ciphertext,
        lut: &ShortintWopbsLUT,
    ) -> Ciphertext {
        let ct_wopbs = self.keyswitch_to_wopbs_params(sks, ct_in);
        let result_ct = self.wopbs(&ct_wopbs, lut);

        self.keyswitch_to_pbs_params(&result_ct)
    }

    /// Apply the Look-Up Table homomorphically using the WoPBS approach.
    ///
    /// #Warning: this assumes one bit of padding.
    /// #Warning: to use in a WoPBS context ONLY (i.e., non compliant with classical PBS)
    ///
    /// # Example
    ///
    /// ```rust
    /// use rand::Rng;
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs_message_carry::WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS;
    /// use tfhe::shortint::wopbs::*;
    ///
    /// // Generate the client key and the server key:
    /// let (cks, sks) = gen_keys(WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS);
    /// let wopbs_key = WopbsKey::new_wopbs_key_only_for_wopbs(&cks, &sks);
    /// let mut rng = rand::thread_rng();
    /// let message_modulus = WOPBS_PARAM_MESSAGE_2_CARRY_2_KS_PBS.message_modulus.0;
    /// let ct = cks.encrypt(rng.gen::<u64>() % message_modulus as u64);
    /// let lut = vec![(1_u64 << 59); wopbs_key.param.polynomial_size.0].into();
    /// let ct_res = wopbs_key.wopbs(&ct, &lut);
    /// let res = cks.decrypt_message_and_carry(&ct_res);
    /// assert_eq!(res, 1);
    /// ```
    pub fn wopbs(&self, ct_in: &Ciphertext, lut: &ShortintWopbsLUT) -> Ciphertext {
        let tmp_sks = &self.wopbs_server_key;
        let message_modulus = tmp_sks.message_modulus.0 as u64;
        let carry_modulus = tmp_sks.carry_modulus.0 as u64;
        let delta = (1u64 << 63) / (carry_modulus * message_modulus);
        // casting to usize is fine, ilog2 of u64 is guaranteed to be < 64
        let delta_log = DeltaLog(delta.ilog2() as usize);
        let nb_bit_to_extract = f64::log2((message_modulus * carry_modulus) as f64) as usize;

        let ct_out = self.extract_bits_circuit_bootstrapping(
            ct_in,
            lut.as_ref(),
            delta_log,
            ExtractedBitsCount(nb_bit_to_extract),
        );

        ct_out
    }

    /// Apply the Look-Up Table homomorphically using the WoPBS approach.
    ///
    /// # Example
    ///
    /// ```rust
    /// use rand::Rng;
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs::WOPBS_PARAM_MESSAGE_1_NORM2_2_KS_PBS;
    /// use tfhe::shortint::wopbs::*;
    ///
    /// let (cks, sks) = gen_keys(WOPBS_PARAM_MESSAGE_1_NORM2_2_KS_PBS);
    /// let wopbs_key = WopbsKey::new_wopbs_key_only_for_wopbs(&cks, &sks);
    /// let mut rng = rand::thread_rng();
    /// let ct = cks.encrypt_without_padding(rng.gen::<u64>() % 2);
    /// let lut = vec![(1_u64 << 63); wopbs_key.param.polynomial_size.0].into();
    /// let ct_res = wopbs_key.programmable_bootstrapping_without_padding(&ct, &lut);
    /// let res = cks.decrypt_message_and_carry_without_padding(&ct_res);
    /// assert_eq!(res, 1);
    /// ```
    pub fn programmable_bootstrapping_without_padding(
        &self,
        ct_in: &Ciphertext,
        lut: &ShortintWopbsLUT,
    ) -> Ciphertext {
        let sks = &self.wopbs_server_key;
        let message_modulus = sks.message_modulus.0 as u64;
        let carry_modulus = sks.carry_modulus.0 as u64;
        let delta = (1u64 << 63) / (carry_modulus * message_modulus) * 2;
        // casting to usize is fine, ilog2 of u64 is guaranteed to be < 64
        let delta_log = DeltaLog(delta.ilog2() as usize);

        let nb_bit_to_extract =
            f64::log2((sks.message_modulus.0 * sks.carry_modulus.0) as f64) as usize;

        let ciphertext = self.extract_bits_circuit_bootstrapping(
            ct_in,
            lut.as_ref(),
            delta_log,
            ExtractedBitsCount(nb_bit_to_extract),
        );

        ciphertext
    }

    /// Apply the Look-Up Table homomorphically using the WoPBS approach.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tfhe::shortint::gen_keys;
    /// use tfhe::shortint::parameters::parameters_wopbs_message_carry::WOPBS_PARAM_MESSAGE_3_CARRY_3_KS_PBS;
    /// use tfhe::shortint::wopbs::*;
    ///
    /// let (cks, sks) = gen_keys(WOPBS_PARAM_MESSAGE_3_CARRY_3_KS_PBS);
    /// let wopbs_key = WopbsKey::new_wopbs_key_only_for_wopbs(&cks, &sks);
    /// let msg = 2;
    /// let modulus = 5;
    /// let ct = cks.encrypt_native_crt(msg, modulus);
    /// let lut = wopbs_key.generate_lut_native_crt(&ct, |x| x);
    /// let ct_res = wopbs_key.programmable_bootstrapping_native_crt(&ct, &lut);
    /// let res = cks.decrypt_message_native_crt(&ct_res, modulus);
    /// assert_eq!(res, msg);
    /// ```
    pub fn programmable_bootstrapping_native_crt(
        &self,
        ct_in: &Ciphertext,
        lut: &ShortintWopbsLUT,
    ) -> Ciphertext {
        let nb_bit_to_extract =
            f64::log2((ct_in.message_modulus.0 * ct_in.carry_modulus.0) as f64).ceil() as usize;
        let delta_log = DeltaLog(64 - nb_bit_to_extract);

        // We need to add a corrective term, so clone the input
        let mut ct_in = ct_in.clone();

        // trick ( ct - delta/2 + delta/2^4  )
        lwe_ciphertext_plaintext_sub_assign(
            &mut ct_in.ct,
            Plaintext((1 << (64 - nb_bit_to_extract - 1)) - (1 << (64 - nb_bit_to_extract - 5))),
        );

        let ciphertext = self.extract_bits_circuit_bootstrapping(
            &ct_in,
            lut.as_ref(),
            delta_log,
            ExtractedBitsCount(nb_bit_to_extract),
        );

        ciphertext
    }

    /// Extract the given number of bits from a ciphertext.
    ///
    /// # Warning Experimental
    pub fn extract_bits(
        &self,
        delta_log: DeltaLog,
        ciphertext: &Ciphertext,
        num_bits_to_extract: ExtractedBitsCount,
    ) -> LweCiphertextListOwned<u64> {
        let server_key = &self.wopbs_server_key;

        let lwe_size = server_key
            .key_switching_key
            .output_key_lwe_dimension()
            .to_lwe_size();

        let mut output = LweCiphertextListOwned::new(
            0u64,
            lwe_size,
            LweCiphertextCount(num_bits_to_extract.0),
            self.param.ciphertext_modulus,
        );

        self.extract_bits_assign(delta_log, ciphertext, num_bits_to_extract, &mut output);

        output
    }

    /// Extract the given number of bits from a ciphertext.
    ///
    /// # Warning Experimental
    pub fn extract_bits_assign<OutputCont>(
        &self,
        delta_log: DeltaLog,
        ciphertext: &Ciphertext,
        num_bits_to_extract: ExtractedBitsCount,
        output: &mut LweCiphertextList<OutputCont>,
    ) where
        OutputCont: ContainerMut<Element = u64>,
    {
        let server_key = &self.wopbs_server_key;

        let bsk = &server_key.bootstrapping_key;
        let ksk = &server_key.key_switching_key;

        let fft = Fft::new(bsk.polynomial_size());
        let fft = fft.as_view();

        ShortintEngine::with_thread_local_mut(|engine| {
            engine.computation_buffers.resize(
                extract_bits_from_lwe_ciphertext_mem_optimized_requirement::<u64>(
                    ciphertext.ct.lwe_size().to_lwe_dimension(),
                    ksk.output_key_lwe_dimension(),
                    bsk.glwe_size(),
                    bsk.polynomial_size(),
                    fft,
                )
                .unwrap()
                .unaligned_bytes_required(),
            );

            let stack = engine.computation_buffers.stack();

            match bsk {
                ShortintBootstrappingKey::Classic(bsk) => {
                    extract_bits_from_lwe_ciphertext_mem_optimized(
                        &ciphertext.ct,
                        output,
                        bsk,
                        ksk,
                        delta_log,
                        num_bits_to_extract,
                        fft,
                        stack,
                    );
                }
                ShortintBootstrappingKey::MultiBit { .. } => {
                    todo!("extract_bits_assign currently does not support multi-bit PBS")
                }
            }
        });
    }

    /// Temporary wrapper.
    ///
    /// # Warning Experimental
    pub fn circuit_bootstrapping_vertical_packing<InputCont>(
        &self,
        vec_lut: &WopbsLUTBase,
        extracted_bits_blocks: &LweCiphertextList<InputCont>,
    ) -> Vec<LweCiphertextOwned<u64>>
    where
        InputCont: Container<Element = u64>,
    {
        let output_list = self.circuit_bootstrap_with_bits(
            extracted_bits_blocks,
            &vec_lut.lut(),
            LweCiphertextCount(vec_lut.output_ciphertext_count().0),
        );

        assert_eq!(
            output_list.lwe_ciphertext_count().0,
            vec_lut.output_ciphertext_count().0
        );

        let output_container = output_list.into_container();
        let ciphertext_modulus = self.param.ciphertext_modulus;
        let lwes: Vec<_> = output_container
            .chunks_exact(output_container.len() / vec_lut.output_ciphertext_count().0)
            .map(|s| LweCiphertextOwned::from_container(s.to_vec(), ciphertext_modulus))
            .collect();

        assert_eq!(lwes.len(), vec_lut.output_ciphertext_count().0);
        lwes
    }

    pub fn keyswitch_to_pbs_params(&self, ct_in: &Ciphertext) -> Ciphertext {
        // move to wopbs parameters to pbs parameters
        //Keyswitch-PBS:
        // 1. KS to go back to the original encryption key
        // 2. PBS to remove the noise added by the previous KS
        //
        let acc = self.pbs_server_key.generate_lookup_table(|x| x);

        ShortintEngine::with_thread_local_mut(|engine| {
            let (mut ciphertext_buffers, buffers) = engine.get_buffers(&self.pbs_server_key);
            // Compute a key switch
            keyswitch_lwe_ciphertext(
                &self.pbs_server_key.key_switching_key,
                &ct_in.ct,
                &mut ciphertext_buffers.buffer_lwe_after_ks,
            );

            let ct_out = match &self.pbs_server_key.bootstrapping_key {
                ShortintBootstrappingKey::Classic(fourier_bsk) => {
                    let out_lwe_size = fourier_bsk.output_lwe_dimension().to_lwe_size();
                    let mut ct_out =
                        LweCiphertextOwned::new(0, out_lwe_size, self.param.ciphertext_modulus);

                    let fft = Fft::new(fourier_bsk.polynomial_size());
                    let fft = fft.as_view();
                    buffers.resize(
                        programmable_bootstrap_lwe_ciphertext_mem_optimized_requirement::<u64>(
                            fourier_bsk.glwe_size(),
                            fourier_bsk.polynomial_size(),
                            fft,
                        )
                        .unwrap()
                        .unaligned_bytes_required(),
                    );
                    let stack = buffers.stack();

                    // Compute a bootstrap
                    programmable_bootstrap_lwe_ciphertext_mem_optimized(
                        &ciphertext_buffers.buffer_lwe_after_ks,
                        &mut ct_out,
                        &acc.acc,
                        fourier_bsk,
                        fft,
                        stack,
                    );

                    ct_out
                }
                ShortintBootstrappingKey::MultiBit { .. } => {
                    return Err(WopbsKeyCreationError::UnsupportedMultiBit);
                }
            };
            Ok(Ciphertext::new(
                ct_out,
                ct_in.degree,
                NoiseLevel::NOMINAL,
                ct_in.message_modulus,
                ct_in.carry_modulus,
                ct_in.pbs_order,
            ))
        })
        .unwrap()
    }

    pub fn keyswitch_to_wopbs_params(&self, sks: &ServerKey, ct_in: &Ciphertext) -> Ciphertext {
        // First PBS to remove the noise
        let acc = sks.generate_lookup_table(|x| x);
        let ct_clean = sks.apply_lookup_table(ct_in, &acc);

        let mut buffer_lwe_after_ks = LweCiphertextOwned::new(
            0,
            self.ksk_pbs_to_wopbs
                .output_key_lwe_dimension()
                .to_lwe_size(),
            self.param.ciphertext_modulus,
        );

        // Compute a key switch
        keyswitch_lwe_ciphertext(
            &self.ksk_pbs_to_wopbs,
            &ct_clean.ct,
            &mut buffer_lwe_after_ks,
        );

        // The identity lut wrongly sets the max degree in the ciphertext, when in reality the
        // degree of the ciphertext has no changed, we manage this case manually here
        Ciphertext::new(
            buffer_lwe_after_ks,
            ct_in.degree,
            NoiseLevel::NOMINAL,
            ct_clean.message_modulus,
            ct_clean.carry_modulus,
            ct_in.pbs_order,
        )
    }

    pub(crate) fn circuit_bootstrap_with_bits<InputCont, LutCont>(
        &self,
        extracted_bits: &LweCiphertextList<InputCont>,
        lut: &PlaintextList<LutCont>,
        count: LweCiphertextCount,
    ) -> LweCiphertextListOwned<u64>
    where
        InputCont: Container<Element = u64>,
        LutCont: Container<Element = u64>,
    {
        let sks = &self.wopbs_server_key;
        let fourier_bsk = &sks.bootstrapping_key;

        let output_lwe_size = fourier_bsk.output_lwe_dimension().to_lwe_size();

        let mut output_cbs_vp_ct = LweCiphertextListOwned::new(
            0u64,
            output_lwe_size,
            count,
            self.param.ciphertext_modulus,
        );
        let lut = PolynomialListView::from_container(lut.as_ref(), fourier_bsk.polynomial_size());

        let fft = Fft::new(fourier_bsk.polynomial_size());
        let fft = fft.as_view();

        ShortintEngine::with_thread_local_mut(|engine| {
            engine.computation_buffers.resize(
                circuit_bootstrap_boolean_vertical_packing_lwe_ciphertext_list_mem_optimized_requirement::<u64>(
                    extracted_bits.lwe_ciphertext_count(),
                    output_cbs_vp_ct.lwe_ciphertext_count(),
                    extracted_bits.lwe_size(),
                    lut.polynomial_count(),
                    fourier_bsk.output_lwe_dimension().to_lwe_size(),
                    fourier_bsk.glwe_size(),
                    self.cbs_pfpksk.output_polynomial_size(),
                    self.param.cbs_level,
                    fft,
                )
                .unwrap()
                .unaligned_bytes_required(),
            );

            let stack = engine.computation_buffers.stack();

            match &sks.bootstrapping_key {
                ShortintBootstrappingKey::Classic(bsk) => {
                    circuit_bootstrap_boolean_vertical_packing_lwe_ciphertext_list_mem_optimized(
                        extracted_bits,
                        &mut output_cbs_vp_ct,
                        &lut,
                        bsk,
                        &self.cbs_pfpksk,
                        self.param.cbs_base_log,
                        self.param.cbs_level,
                        fft,
                        stack,
                    );
                }
                ShortintBootstrappingKey::MultiBit { .. } => {
                    return Err(WopbsKeyCreationError::UnsupportedMultiBit);
                }
            };
            Ok(())
        }).unwrap();

        output_cbs_vp_ct
    }

    pub(crate) fn extract_bits_circuit_bootstrapping(
        &self,
        ct_in: &Ciphertext,
        lut: &WopbsLUTBase,
        delta_log: DeltaLog,
        nb_bit_to_extract: ExtractedBitsCount,
    ) -> Ciphertext {
        let extracted_bits = self.extract_bits(delta_log, ct_in, nb_bit_to_extract);

        let ciphertext_list = self.circuit_bootstrap_with_bits(
            &extracted_bits.as_view(),
            &lut.lut(),
            LweCiphertextCount(1),
        );

        // Here the output list contains a single ciphertext, we can consume the container to
        // convert it to a single ciphertext
        let ciphertext = LweCiphertextOwned::from_container(
            ciphertext_list.into_container(),
            self.param.ciphertext_modulus,
        );

        let sks = &self.wopbs_server_key;

        Ciphertext::new(
            ciphertext,
            Degree::new(sks.message_modulus.0 - 1),
            NoiseLevel::NOMINAL,
            sks.message_modulus,
            sks.carry_modulus,
            ct_in.pbs_order,
        )
    }
}
