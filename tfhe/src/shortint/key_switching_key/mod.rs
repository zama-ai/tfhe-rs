//! This module defines KeySwitchingKey
//!
//! - [KeySwitchingKey] allows switching the keys of a ciphertext, from a cleitn key to another.

use crate::conformance::ParameterSetConformant;
use crate::core_crypto::prelude::{
    keyswitch_lwe_ciphertext, Cleartext, KeyswitchKeyConformanceParams, LweKeyswitchKeyOwned,
    SeededLweKeyswitchKeyOwned,
};
use crate::shortint::ciphertext::Degree;
use crate::shortint::client_key::secret_encryption_key::SecretEncryptionKeyView;
use crate::shortint::engine::ShortintEngine;
use crate::shortint::parameters::{
    EncryptionKeyChoice, NoiseLevel, PBSOrder, ShortintKeySwitchingParameters,
};
use crate::shortint::server_key::apply_programmable_bootstrap;
use crate::shortint::{Ciphertext, ClientKey, CompressedServerKey, MaxNoiseLevel, ServerKey};
use core::cmp::Ordering;
use rayon::prelude::*;
use serde::{Deserialize, Serialize};
use tfhe_versionable::Versionize;

use super::backward_compatibility::key_switching_key::{
    CompressedKeySwitchingKeyMaterialVersions, CompressedKeySwitchingKeyVersions,
    KeySwitchingKeyMaterialVersions, KeySwitchingKeyVersions,
};

#[cfg(test)]
mod test;

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Versionize)]
#[versionize(KeySwitchingKeyMaterialVersions)]
pub struct KeySwitchingKeyMaterial {
    pub(crate) key_switching_key: LweKeyswitchKeyOwned<u64>,
    pub(crate) cast_rshift: i8,
    pub(crate) destination_key: EncryptionKeyChoice,
}

impl KeySwitchingKeyMaterial {
    pub fn into_raw_parts(self) -> (LweKeyswitchKeyOwned<u64>, i8, EncryptionKeyChoice) {
        let Self {
            key_switching_key,
            cast_rshift,
            destination_key,
        } = self;
        (key_switching_key, cast_rshift, destination_key)
    }

    pub fn from_raw_parts(
        key_switching_key: LweKeyswitchKeyOwned<u64>,
        cast_rshift: i8,
        destination_key: EncryptionKeyChoice,
    ) -> Self {
        Self {
            key_switching_key,
            cast_rshift,
            destination_key,
        }
    }

    pub fn as_view(&self) -> KeySwitchingKeyMaterialView<'_> {
        KeySwitchingKeyMaterialView {
            key_switching_key: &self.key_switching_key,
            cast_rshift: self.cast_rshift,
            destination_key: self.destination_key,
        }
    }
}

// This is used to have the ability to build a keyswitching key without owning the ServerKey
// It is a bit of a hack, but at this point it seems ok
pub(crate) struct KeySwitchingKeyBuildHelper<'keys> {
    pub(crate) key_switching_key_material: KeySwitchingKeyMaterial,
    pub(crate) dest_server_key: &'keys ServerKey,
    pub(crate) src_server_key: Option<&'keys ServerKey>,
}

/// A structure containing the casting public key.
///
/// The casting key is generated by the client and is meant to be published: the client
/// sends it to the server so it can cast from one set of parameters to another.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Versionize)]
#[versionize(KeySwitchingKeyVersions)]
pub struct KeySwitchingKey {
    pub(crate) key_switching_key_material: KeySwitchingKeyMaterial,
    pub(crate) dest_server_key: ServerKey,
    pub(crate) src_server_key: Option<ServerKey>,
}

impl From<KeySwitchingKeyBuildHelper<'_>> for KeySwitchingKey {
    fn from(value: KeySwitchingKeyBuildHelper) -> Self {
        let KeySwitchingKeyBuildHelper {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        } = value;

        Self {
            key_switching_key_material,
            dest_server_key: dest_server_key.to_owned(),
            src_server_key: src_server_key.map(ToOwned::to_owned),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct KeySwitchingKeyMaterialView<'key> {
    pub(crate) key_switching_key: &'key LweKeyswitchKeyOwned<u64>,
    pub(crate) cast_rshift: i8,
    pub(crate) destination_key: EncryptionKeyChoice,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct KeySwitchingKeyView<'keys> {
    pub(crate) key_switching_key_material: KeySwitchingKeyMaterialView<'keys>,
    pub(crate) dest_server_key: &'keys ServerKey,
    pub(crate) src_server_key: Option<&'keys ServerKey>,
}

impl<'keys> KeySwitchingKeyBuildHelper<'keys> {
    pub(crate) fn new<'input_key, InputEncryptionKey>(
        input_key_pair: (InputEncryptionKey, Option<&'keys ServerKey>),
        output_key_pair: (&'keys ClientKey, &'keys ServerKey),
        params: ShortintKeySwitchingParameters,
    ) -> Self
    where
        InputEncryptionKey: Into<SecretEncryptionKeyView<'input_key>>,
    {
        let input_secret_key: SecretEncryptionKeyView<'_> = input_key_pair.0.into();

        // Creation of the key switching key
        let key_switching_key = ShortintEngine::with_thread_local_mut(|engine| {
            engine.new_key_switching_key(&input_secret_key, output_key_pair.0, params)
        });

        let full_message_modulus_input =
            input_secret_key.carry_modulus.0 * input_secret_key.message_modulus.0;
        let full_message_modulus_output = output_key_pair.0.parameters.carry_modulus().0
            * output_key_pair.0.parameters.message_modulus().0;
        assert!(
            full_message_modulus_input.is_power_of_two()
                && full_message_modulus_output.is_power_of_two(),
            "Cannot create casting key if the full messages moduli are not a power of 2"
        );
        if full_message_modulus_input > full_message_modulus_output {
            assert!(
                input_key_pair.1.is_some(),
                "Trying to build a shortint::KeySwitchingKey \
                going from a large modulus {full_message_modulus_input} \
                to a smaller modulus {full_message_modulus_output} \
                without providing a source ServerKey, this is not supported"
            );
        }

        let nb_bits_input: i8 = full_message_modulus_input.ilog2().try_into().unwrap();
        let nb_bits_output: i8 = full_message_modulus_output.ilog2().try_into().unwrap();

        // Pack the keys in the casting key set:
        Self {
            key_switching_key_material: KeySwitchingKeyMaterial {
                key_switching_key,
                cast_rshift: nb_bits_output - nb_bits_input,
                destination_key: params.destination_key,
            },
            dest_server_key: output_key_pair.1,
            src_server_key: input_key_pair.1,
        }
    }
}

impl KeySwitchingKey {
    /// Generate a casting key. This can cast to several kinds of keys (shortint, integer, hlapi),
    /// depending on input.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tfhe::shortint::parameters::{
    ///     V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64,
    ///     V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64,
    /// };
    /// use tfhe::shortint::prelude::*;
    /// use tfhe::shortint::{gen_keys, KeySwitchingKey};
    ///
    /// // Generate the client keys and server keys:
    /// let (ck1, sk1) = gen_keys(V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64);
    /// let (ck2, sk2) = gen_keys(V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64);
    ///
    /// // Generate the server key:
    /// let ksk = KeySwitchingKey::new(
    ///     (&ck1, Some(&sk1)),
    ///     (&ck2, &sk2),
    ///     V0_11_PARAM_KEYSWITCH_1_1_KS_PBS_TO_2_2_KS_PBS,
    /// );
    /// ```
    pub fn new<'input_key, InputEncryptionKey>(
        input_key_pair: (InputEncryptionKey, Option<&ServerKey>),
        output_key_pair: (&ClientKey, &ServerKey),
        params: ShortintKeySwitchingParameters,
    ) -> Self
    where
        InputEncryptionKey: Into<SecretEncryptionKeyView<'input_key>>,
    {
        KeySwitchingKeyBuildHelper::new(input_key_pair, output_key_pair, params).into()
    }

    pub fn as_view(&self) -> KeySwitchingKeyView<'_> {
        let Self {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        } = self;

        KeySwitchingKeyView {
            key_switching_key_material: key_switching_key_material.as_view(),
            dest_server_key,
            src_server_key: src_server_key.as_ref(),
        }
    }

    /// Deconstruct a [`KeySwitchingKey`] into its constituents.
    pub fn into_raw_parts(self) -> (KeySwitchingKeyMaterial, ServerKey, Option<ServerKey>) {
        let Self {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        } = self;

        (key_switching_key_material, dest_server_key, src_server_key)
    }

    /// Construct a [`KeySwitchingKey`] from its constituents.
    ///
    /// # Panics
    ///
    /// Panics if the provided raw parts are not compatible with each other, i.e.:
    ///
    /// if the provided source [`ServerKey`] ciphertext
    /// [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) does not match the
    /// input [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) of the
    /// [`LweKeyswitchKeyOwned`] in the provided [`KeySwitchingKeyMaterial`] or if the provided
    /// destination [`ServerKey`] ciphertext
    /// [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) does not match
    /// the output [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) of
    /// the [`LweKeyswitchKeyOwned`] in the provided [`KeySwitchingKeyMaterial`].
    pub fn from_raw_parts(
        key_switching_key_material: KeySwitchingKeyMaterial,
        dest_server_key: ServerKey,
        src_server_key: Option<ServerKey>,
    ) -> Self {
        match src_server_key {
            Some(ref src_server_key) => {
                let src_lwe_dimension = src_server_key.ciphertext_lwe_dimension();

                assert_eq!(
                    src_lwe_dimension,
                    key_switching_key_material
                        .key_switching_key
                        .input_key_lwe_dimension(),
                    "Mismatch between the source ServerKey ciphertext LweDimension ({:?}) \
                    and the LweKeyswitchKey input LweDimension ({:?})",
                    src_lwe_dimension,
                    key_switching_key_material
                        .key_switching_key
                        .input_key_lwe_dimension(),
                );

                assert_eq!(
                    src_server_key.ciphertext_modulus, dest_server_key.ciphertext_modulus,
                    "Mismatch between the source ServerKey CiphertextModulus ({:?}) \
                    and the destination ServerKey CiphertextModulus ({:?})",
                    src_server_key.ciphertext_modulus, dest_server_key.ciphertext_modulus,
                );
            }
            None => assert!(
                key_switching_key_material.cast_rshift >= 0,
                "Trying to build a shortint::KeySwitchingKey with a negative cast_rshift \
                without providing a source ServerKey, this is not supported"
            ),
        }

        let dst_lwe_dimension = match key_switching_key_material.destination_key {
            EncryptionKeyChoice::Big => dest_server_key.bootstrapping_key.output_lwe_dimension(),
            EncryptionKeyChoice::Small => dest_server_key.bootstrapping_key.input_lwe_dimension(),
        };

        assert_eq!(
            dst_lwe_dimension,
            key_switching_key_material
                .key_switching_key
                .output_key_lwe_dimension(),
            "Mismatch between the destination ServerKey ciphertext LweDimension ({:?}) \
            and the LweKeyswitchKey output LweDimension ({:?})",
            dst_lwe_dimension,
            key_switching_key_material
                .key_switching_key
                .output_key_lwe_dimension(),
        );
        assert_eq!(
            key_switching_key_material
                .key_switching_key
                .ciphertext_modulus(),
            dest_server_key.ciphertext_modulus,
            "Mismatch between the LweKeyswitchKey CiphertextModulus ({:?}) \
            and the destination ServerKey CiphertextModulus ({:?})",
            key_switching_key_material
                .key_switching_key
                .ciphertext_modulus(),
            dest_server_key.ciphertext_modulus,
        );

        Self {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        }
    }

    /// Cast a ciphertext from the source parameter set to the dest parameter set,
    /// returning a new ciphertext.
    ///
    /// # Example (the following code won't actually run because this function is private)
    ///
    /// ```rust
    /// use tfhe::shortint::parameters::{
    ///     V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64,
    ///     V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64,
    /// };
    /// use tfhe::shortint::prelude::*;
    /// use tfhe::shortint::{gen_keys, KeySwitchingKey};
    ///
    /// // Generate the client keys and server keys:
    /// let (ck1, sk1) = gen_keys(V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64);
    /// let (ck2, sk2) = gen_keys(V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64);
    ///
    /// // Generate the server key:
    /// let ksk = KeySwitchingKey::new(
    ///     (&ck1, Some(&sk1)),
    ///     (&ck2, &sk2),
    ///     V0_11_PARAM_KEYSWITCH_1_1_KS_PBS_TO_2_2_KS_PBS,
    /// );
    ///
    /// let cleartext = 1;
    ///
    /// let cipher = ck1.encrypt(cleartext);
    /// let cipher_2 = ksk.cast(&cipher);
    ///
    /// assert_eq!(ck2.decrypt(&cipher_2), cleartext);
    /// ```
    pub fn cast(&self, input_ct: &Ciphertext) -> Ciphertext {
        self.as_view().cast(input_ct)
    }
}

impl<'keys> KeySwitchingKeyView<'keys> {
    /// Deconstruct a [`KeySwitchingKeyView`] into its constituents.
    pub fn into_raw_parts(
        self,
    ) -> (
        KeySwitchingKeyMaterialView<'keys>,
        &'keys ServerKey,
        Option<&'keys ServerKey>,
    ) {
        let Self {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        } = self;

        (key_switching_key_material, dest_server_key, src_server_key)
    }

    /// Construct a [`KeySwitchingKeyView`] from its constituents.
    ///
    /// # Panics
    ///
    /// Panics if the provided raw parts are not compatible with each other, i.e.:
    ///
    /// if the provided source [`ServerKey`] ciphertext
    /// [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) does not match the
    /// input [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) of the
    /// [`LweKeyswitchKeyOwned`] in the provided [`KeySwitchingKeyMaterial`] or if the provided
    /// destination [`ServerKey`] ciphertext
    /// [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) does not match
    /// the output [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) of
    /// the [`LweKeyswitchKeyOwned`] in the provided [`KeySwitchingKeyMaterial`].
    pub fn from_raw_parts(
        key_switching_key_material: KeySwitchingKeyMaterialView<'keys>,
        dest_server_key: &'keys ServerKey,
        src_server_key: Option<&'keys ServerKey>,
    ) -> Self {
        match src_server_key {
            Some(src_server_key) => {
                let src_lwe_dimension = src_server_key.ciphertext_lwe_dimension();

                assert_eq!(
                    src_lwe_dimension,
                    key_switching_key_material
                        .key_switching_key
                        .input_key_lwe_dimension(),
                    "Mismatch between the source ServerKey ciphertext LweDimension ({:?}) \
                    and the LweKeyswitchKey input LweDimension ({:?})",
                    src_lwe_dimension,
                    key_switching_key_material
                        .key_switching_key
                        .input_key_lwe_dimension(),
                );

                assert_eq!(
                    src_server_key.ciphertext_modulus, dest_server_key.ciphertext_modulus,
                    "Mismatch between the source ServerKey CiphertextModulus ({:?}) \
                    and the destination ServerKey CiphertextModulus ({:?})",
                    src_server_key.ciphertext_modulus, dest_server_key.ciphertext_modulus,
                );
            }
            None => assert!(
                key_switching_key_material.cast_rshift >= 0,
                "Trying to build a shortint::KeySwitchingKey with a negative cast_rshift \
                without providing a source ServerKey, this is not supported"
            ),
        }

        let dst_lwe_dimension = match key_switching_key_material.destination_key {
            EncryptionKeyChoice::Big => dest_server_key.bootstrapping_key.output_lwe_dimension(),
            EncryptionKeyChoice::Small => dest_server_key.bootstrapping_key.input_lwe_dimension(),
        };

        assert_eq!(
            dst_lwe_dimension,
            key_switching_key_material
                .key_switching_key
                .output_key_lwe_dimension(),
            "Mismatch between the destination ServerKey ciphertext LweDimension ({:?}) \
            and the LweKeyswitchKey output LweDimension ({:?})",
            dst_lwe_dimension,
            key_switching_key_material
                .key_switching_key
                .output_key_lwe_dimension(),
        );
        assert_eq!(
            key_switching_key_material
                .key_switching_key
                .ciphertext_modulus(),
            dest_server_key.ciphertext_modulus,
            "Mismatch between the LweKeyswitchKey CiphertextModulus ({:?}) \
            and the destination ServerKey CiphertextModulus ({:?})",
            key_switching_key_material
                .key_switching_key
                .ciphertext_modulus(),
            dest_server_key.ciphertext_modulus,
        );

        Self {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        }
    }

    /// Cast a ciphertext from the source parameter set to the dest parameter set,
    /// returning a new ciphertext.
    ///
    /// # Example (the following code won't actually run because this function is private)
    ///
    /// ```rust
    /// use tfhe::shortint::parameters::{
    ///     V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64,
    ///     V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64,
    /// };
    /// use tfhe::shortint::prelude::*;
    /// use tfhe::shortint::{gen_keys, KeySwitchingKey};
    ///
    /// // Generate the client keys and server keys:
    /// let (ck1, sk1) = gen_keys(V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64);
    /// let (ck2, sk2) = gen_keys(V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64);
    ///
    /// // Generate the server key:
    /// let ksk = KeySwitchingKey::new(
    ///     (&ck1, Some(&sk1)),
    ///     (&ck2, &sk2),
    ///     V0_11_PARAM_KEYSWITCH_1_1_KS_PBS_TO_2_2_KS_PBS,
    /// );
    ///
    /// let cleartext = 1;
    ///
    /// let cipher = ck1.encrypt(cleartext);
    /// let cipher_2 = ksk.cast(&cipher);
    ///
    /// assert_eq!(ck2.decrypt(&cipher_2), cleartext);
    /// ```
    pub fn cast(&self, input_ct: &Ciphertext) -> Ciphertext {
        let res = self.cast_and_apply_functions(input_ct, None);
        assert_eq!(res.len(), 1);
        res.into_iter().next().unwrap()
    }

    /// Cast a ciphertext from the source parameter set to the dest parameter set,
    /// returning a new ciphertext.
    ///
    /// If None is provided then an identity function is used and tighter degrees are used where
    /// applicable.
    pub fn cast_and_apply_functions(
        &self,
        input_ct: &Ciphertext,
        functions: Option<&[&(dyn Fn(u64) -> u64 + Sync)]>,
    ) -> Vec<Ciphertext> {
        let output_lwe_size = match self.key_switching_key_material.destination_key {
            EncryptionKeyChoice::Big => self
                .dest_server_key
                .bootstrapping_key
                .output_lwe_dimension()
                .to_lwe_size(),
            EncryptionKeyChoice::Small => self
                .dest_server_key
                .bootstrapping_key
                .input_lwe_dimension()
                .to_lwe_size(),
        };
        let mut keyswitched = self
            .dest_server_key
            .unchecked_create_trivial_with_lwe_size(Cleartext(0), output_lwe_size);

        // TODO: We are outside the standard AP, if we chain keyswitches, we will refresh, which is
        // safer for now. We can likely add an additional flag in shortint to indicate if we
        // want to refresh or not, for now refresh anyways.
        keyswitched.set_noise_level(NoiseLevel::UNKNOWN, MaxNoiseLevel::UNKNOWN);

        let cast_rshift = self.key_switching_key_material.cast_rshift;

        // First pre process
        let tmp_preprocessed: Ciphertext;

        let pre_processed = match cast_rshift.cmp(&0) {
            // Cast to smaller bit length: left shift, then keyswitch
            Ordering::Less => {
                let src_server_key = self.src_server_key.as_ref().expect(
                    "No source server key in shortint::KeySwitchingKey \
                    which is required when casting to a smaller message modulus",
                );
                // We want to avoid the padding bit to be dirty, hence the modulus
                let acc = src_server_key.generate_lookup_table(|n| {
                    (n << -cast_rshift) % (input_ct.carry_modulus.0 * input_ct.message_modulus.0)
                });
                tmp_preprocessed = src_server_key.apply_lookup_table(input_ct, &acc);
                &tmp_preprocessed
            }
            // No pre-processing
            Ordering::Equal | Ordering::Greater => input_ct,
        };

        // The keyswitch
        keyswitch_lwe_ciphertext(
            self.key_switching_key_material.key_switching_key,
            &pre_processed.ct,
            &mut keyswitched.ct,
        );
        keyswitched.degree = pre_processed.degree;

        let degree_after_keyswitch = keyswitched.degree;

        enum CastCiphertext {
            CorrectKey(Ciphertext),
            WrongKeyRequiresPBS(Ciphertext),
        }

        // Manage the destination key adjustment
        let res = {
            let destination_pbs_order: PBSOrder =
                self.key_switching_key_material.destination_key.into();
            if destination_pbs_order == self.dest_server_key.pbs_order {
                CastCiphertext::CorrectKey(keyswitched)
            } else {
                // We are arriving under the wrong key for the dest_server_key
                match self.key_switching_key_material.destination_key {
                    // Big to Small == keyswitch
                    EncryptionKeyChoice::Big => {
                        let wrong_key_ct = keyswitched;
                        let mut correct_key_ct = self.dest_server_key.create_trivial(0);
                        correct_key_ct.degree = wrong_key_ct.degree;
                        correct_key_ct.set_noise_level(
                            wrong_key_ct.noise_level(),
                            self.dest_server_key.max_noise_level,
                        );

                        keyswitch_lwe_ciphertext(
                            &self.dest_server_key.key_switching_key,
                            &wrong_key_ct.ct,
                            &mut correct_key_ct.ct,
                        );

                        CastCiphertext::CorrectKey(correct_key_ct)
                    }
                    // Small to Big == PBS, we handle this in the last part of the function to apply
                    // the refresh and the user functions in similar ways and keep the code easier
                    // to maintain
                    EncryptionKeyChoice::Small => CastCiphertext::WrongKeyRequiresPBS(keyswitched),
                }
            }
        };

        let output_ciphertext_count = functions.map_or_else(|| 1, |x| x.len());
        let mut output_cts = vec![self.dest_server_key.create_trivial(0); output_ciphertext_count];
        let identity_fn_array: &[&(dyn Fn(u64) -> u64 + Sync)] = &[&|x: u64| x];
        let functions_to_use = functions.map_or_else(|| identity_fn_array, |fns| fns);
        let using_user_provided_functions = functions.is_some();
        let using_identity_lut = !using_user_provided_functions;

        match cast_rshift.cmp(&0) {
            // Same bit size
            Ordering::Equal => {
                // Refresh or apply user functions if provided
                match res {
                    CastCiphertext::CorrectKey(ciphertext) => {
                        output_cts
                            .par_iter_mut()
                            .zip(functions_to_use.par_iter())
                            .for_each(|(correct_key_ct, function)| {
                                let acc = self.dest_server_key.generate_lookup_table(function);
                                *correct_key_ct =
                                    self.dest_server_key.apply_lookup_table(&ciphertext, &acc);
                                // If we apply an Identity LUT we know a tighter bound than the
                                // worst case LUT value
                                if using_identity_lut {
                                    correct_key_ct.degree = degree_after_keyswitch;
                                }
                            });
                    }
                    CastCiphertext::WrongKeyRequiresPBS(wrong_key_ct) => {
                        output_cts
                            .par_iter_mut()
                            .zip(functions_to_use.par_iter())
                            .for_each(|(correct_key_ct, function)| {
                                ShortintEngine::with_thread_local_mut(|engine| {
                                    let (_, buffers) = engine.get_buffers(self.dest_server_key);
                                    let acc = self.dest_server_key.generate_lookup_table(function);
                                    apply_programmable_bootstrap(
                                        &self.dest_server_key.bootstrapping_key,
                                        &wrong_key_ct.ct,
                                        &mut correct_key_ct.ct,
                                        &acc.acc,
                                        buffers,
                                    );

                                    // Update degree depending on the LUT used (as this is a PBS and
                                    // not a full apply lookup table)
                                    if using_user_provided_functions {
                                        correct_key_ct.degree = acc.degree;
                                    } else {
                                        correct_key_ct.degree = degree_after_keyswitch;
                                    }
                                    // Update the noise as well
                                    correct_key_ct.set_noise_level(
                                        NoiseLevel::NOMINAL,
                                        self.dest_server_key.max_noise_level,
                                    );
                                });
                            });
                    }
                }
            }
            // Cast to bigger bit length: keyswitch, then right shift, combine this with user
            // function for better efficiency
            Ordering::Greater => {
                match res {
                    CastCiphertext::CorrectKey(ciphertext) => {
                        output_cts
                            .par_iter_mut()
                            .zip(functions_to_use.par_iter())
                            .for_each(|(correct_key_ct, function)| {
                                let acc = self
                                    .dest_server_key
                                    .generate_lookup_table(|n| function(n >> cast_rshift));
                                *correct_key_ct =
                                    self.dest_server_key.apply_lookup_table(&ciphertext, &acc);
                                // degree and noise are updated by the apply lookup table
                            });
                    }
                    CastCiphertext::WrongKeyRequiresPBS(wrong_key_ct) => {
                        output_cts
                            .par_iter_mut()
                            .zip(functions_to_use.par_iter())
                            .for_each(|(correct_key_ct, function)| {
                                ShortintEngine::with_thread_local_mut(|engine| {
                                    let (_, buffers) = engine.get_buffers(self.dest_server_key);
                                    let acc = self.dest_server_key.generate_lookup_table(|n| {
                                        // Call the function on the shifted arrival
                                        // value
                                        function(n >> cast_rshift)
                                    });
                                    apply_programmable_bootstrap(
                                        &self.dest_server_key.bootstrapping_key,
                                        &wrong_key_ct.ct,
                                        &mut correct_key_ct.ct,
                                        &acc.acc,
                                        buffers,
                                    );
                                    // Update degree and noise as it's a raw PBS
                                    correct_key_ct.degree = acc.degree;
                                    correct_key_ct.set_noise_level(
                                        NoiseLevel::NOMINAL,
                                        self.dest_server_key.max_noise_level,
                                    );
                                });
                            });
                    }
                }
            }
            // Cast to smaller bit length: left shift, then keyswitch, then refresh or apply user
            // function.
            Ordering::Less => {
                match res {
                    CastCiphertext::CorrectKey(ciphertext) => {
                        output_cts
                            .par_iter_mut()
                            .zip(functions_to_use.par_iter())
                            .for_each(|(correct_key_ct, function)| {
                                let acc = self.dest_server_key.generate_lookup_table(function);
                                *correct_key_ct =
                                    self.dest_server_key.apply_lookup_table(&ciphertext, &acc);

                                if using_user_provided_functions {
                                    correct_key_ct.degree = acc.degree;
                                } else {
                                    // Note that this relies on the fact that the left shift degree
                                    // is in degree_after_keyswitch.
                                    // The degree is high in the source plaintext modulus, but
                                    // smaller in the arriving one.
                                    //
                                    // src 4 bits:
                                    // 0 | XX | 11
                                    // shifted:
                                    // 0 | 11 | 00 -> Applied lut will have max degree 1100 = 12
                                    // dst 2 bits :
                                    // 0 | 11 -> 11 = 3
                                    let new_degree =
                                        Degree::new(degree_after_keyswitch.get() >> -cast_rshift);
                                    correct_key_ct.degree = new_degree;
                                }
                            });
                    }
                    CastCiphertext::WrongKeyRequiresPBS(wrong_key_ct) => {
                        output_cts
                            .par_iter_mut()
                            .zip(functions_to_use.par_iter())
                            .for_each(|(correct_key_ct, function)| {
                                ShortintEngine::with_thread_local_mut(|engine| {
                                    let (_, buffers) = engine.get_buffers(self.dest_server_key);
                                    let acc = self.dest_server_key.generate_lookup_table(function);
                                    apply_programmable_bootstrap(
                                        &self.dest_server_key.bootstrapping_key,
                                        &wrong_key_ct.ct,
                                        &mut correct_key_ct.ct,
                                        &acc.acc,
                                        buffers,
                                    );
                                    if using_user_provided_functions {
                                        correct_key_ct.degree = acc.degree;
                                    } else {
                                        let new_degree = Degree::new(
                                            degree_after_keyswitch.get() >> -cast_rshift,
                                        );
                                        correct_key_ct.degree = new_degree;
                                    }
                                    correct_key_ct.set_noise_level(
                                        NoiseLevel::NOMINAL,
                                        self.dest_server_key.max_noise_level,
                                    );
                                });
                            });
                    }
                }
            }
        }

        output_cts
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, Versionize)]
#[versionize(CompressedKeySwitchingKeyMaterialVersions)]
pub struct CompressedKeySwitchingKeyMaterial {
    pub(crate) key_switching_key: SeededLweKeyswitchKeyOwned<u64>,
    pub(crate) cast_rshift: i8,
    pub(crate) destination_key: EncryptionKeyChoice,
}

impl CompressedKeySwitchingKeyMaterial {
    pub fn decompress(&self) -> KeySwitchingKeyMaterial {
        let key_switching_key = self
            .key_switching_key
            .as_view()
            .par_decompress_into_lwe_keyswitch_key();

        KeySwitchingKeyMaterial {
            key_switching_key,
            cast_rshift: self.cast_rshift,
            destination_key: self.destination_key,
        }
    }
}

// This is used to have the ability to build a keyswitching key without owning the ServerKey
// It is a bit of a hack, but at this point it seems ok
pub(crate) struct CompressedKeySwitchingKeyBuildHelper<'keys> {
    pub(crate) key_switching_key_material: CompressedKeySwitchingKeyMaterial,
    pub(crate) dest_server_key: &'keys CompressedServerKey,
    pub(crate) src_server_key: Option<&'keys CompressedServerKey>,
}

/// A structure containing the casting public key.
///
/// The casting key is generated by the client and is meant to be published: the client
/// sends it to the server so it can cast from one set of parameters to another.
#[derive(Clone, Debug, Serialize, Deserialize, Versionize)]
#[versionize(CompressedKeySwitchingKeyVersions)]
pub struct CompressedKeySwitchingKey {
    pub(crate) key_switching_key_material: CompressedKeySwitchingKeyMaterial,
    pub(crate) dest_server_key: CompressedServerKey,
    pub(crate) src_server_key: Option<CompressedServerKey>,
}

impl From<CompressedKeySwitchingKeyBuildHelper<'_>> for CompressedKeySwitchingKey {
    fn from(value: CompressedKeySwitchingKeyBuildHelper) -> Self {
        let CompressedKeySwitchingKeyBuildHelper {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        } = value;

        Self {
            key_switching_key_material,
            dest_server_key: dest_server_key.to_owned(),
            src_server_key: src_server_key.map(ToOwned::to_owned),
        }
    }
}

impl<'keys> CompressedKeySwitchingKeyBuildHelper<'keys> {
    pub(crate) fn new<'input_key, InputEncryptionKey>(
        input_key_pair: (InputEncryptionKey, Option<&'keys CompressedServerKey>),
        output_key_pair: (&'keys ClientKey, &'keys CompressedServerKey),
        params: ShortintKeySwitchingParameters,
    ) -> Self
    where
        InputEncryptionKey: Into<SecretEncryptionKeyView<'input_key>>,
    {
        let input_secret_key: SecretEncryptionKeyView<'_> = input_key_pair.0.into();

        // Creation of the key switching key
        let key_switching_key = ShortintEngine::with_thread_local_mut(|engine| {
            engine.new_seeded_key_switching_key(&input_secret_key, output_key_pair.0, params)
        });

        let full_message_modulus_input =
            input_secret_key.carry_modulus.0 * input_secret_key.message_modulus.0;
        let full_message_modulus_output = output_key_pair.0.parameters.carry_modulus().0
            * output_key_pair.0.parameters.message_modulus().0;
        assert!(
            full_message_modulus_input.is_power_of_two()
                && full_message_modulus_output.is_power_of_two(),
            "Cannot create casting key if the full messages moduli are not a power of 2"
        );
        if full_message_modulus_input > full_message_modulus_output {
            assert!(
                input_key_pair.1.is_some(),
                "Trying to build a shortint::KeySwitchingKey \
                going from a large modulus {full_message_modulus_input} \
                to a smaller modulus {full_message_modulus_output} \
                without providing a source ServerKey, this is not supported"
            );
        }

        let nb_bits_input: i8 = full_message_modulus_input.ilog2().try_into().unwrap();
        let nb_bits_output: i8 = full_message_modulus_output.ilog2().try_into().unwrap();

        // Pack the keys in the casting key set:
        Self {
            key_switching_key_material: CompressedKeySwitchingKeyMaterial {
                key_switching_key,
                cast_rshift: nb_bits_output - nb_bits_input,
                destination_key: params.destination_key,
            },
            dest_server_key: output_key_pair.1,
            src_server_key: input_key_pair.1,
        }
    }
}

impl CompressedKeySwitchingKey {
    pub fn new<'input_key, InputEncryptionKey>(
        input_key_pair: (InputEncryptionKey, Option<&CompressedServerKey>),
        output_key_pair: (&ClientKey, &CompressedServerKey),
        params: ShortintKeySwitchingParameters,
    ) -> Self
    where
        InputEncryptionKey: Into<SecretEncryptionKeyView<'input_key>>,
    {
        CompressedKeySwitchingKeyBuildHelper::new(input_key_pair, output_key_pair, params).into()
    }

    pub fn decompress(&self) -> KeySwitchingKey {
        KeySwitchingKey {
            key_switching_key_material: self.key_switching_key_material.decompress(),
            dest_server_key: self.dest_server_key.decompress(),
            src_server_key: self
                .src_server_key
                .as_ref()
                .map(CompressedServerKey::decompress),
        }
    }

    /// Deconstruct a [`CompressedKeySwitchingKey`] into its constituents.
    pub fn into_raw_parts(
        self,
    ) -> (
        CompressedKeySwitchingKeyMaterial,
        CompressedServerKey,
        Option<CompressedServerKey>,
    ) {
        let Self {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        } = self;

        (key_switching_key_material, dest_server_key, src_server_key)
    }

    /// Construct a [`CompressedKeySwitchingKey`] from its constituents.
    ///
    /// # Panics
    ///
    /// Panics if the provided raw parts are not compatible with each other, i.e.:
    ///
    /// if the provided source [`CompressedServerKey`] ciphertext
    /// [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) does not match the
    /// input [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) of the
    /// [`SeededLweKeyswitchKeyOwned`] in the provided [`CompressedKeySwitchingKeyMaterial`] or if
    /// the provided destination [`CompressedServerKey`] ciphertext
    /// [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) does not match
    /// the output [`LweDimension`](`crate::core_crypto::commons::parameters::LweDimension`) of
    /// the [`SeededLweKeyswitchKeyOwned`] in the provided [`CompressedKeySwitchingKeyMaterial`].
    pub fn from_raw_parts(
        key_switching_key_material: CompressedKeySwitchingKeyMaterial,
        dest_server_key: CompressedServerKey,
        src_server_key: Option<CompressedServerKey>,
    ) -> Self {
        match src_server_key {
            Some(ref src_server_key) => {
                let src_lwe_dimension = src_server_key.ciphertext_lwe_dimension();

                assert_eq!(
                    src_lwe_dimension,
                    key_switching_key_material
                        .key_switching_key
                        .input_key_lwe_dimension(),
                    "Mismatch between the source CompressedServerKey ciphertext LweDimension ({:?}) \
                    and the SeededLweKeyswitchKey input LweDimension ({:?})",
                    src_lwe_dimension,
                    key_switching_key_material
                        .key_switching_key
                        .input_key_lwe_dimension(),
                );

                assert_eq!(
                    src_server_key.ciphertext_modulus, dest_server_key.ciphertext_modulus,
                    "Mismatch between the source CompressedServerKey CiphertextModulus ({:?}) \
                    and the destination CompressedServerKey CiphertextModulus ({:?})",
                    src_server_key.ciphertext_modulus, dest_server_key.ciphertext_modulus,
                );
            }
            None => assert!(
                key_switching_key_material.cast_rshift >= 0,
                "Trying to build a shortint::CompressedKeySwitchingKey with a negative cast_rshift \
                without providing a source CompressedServerKey, this is not supported"
            ),
        }

        let dst_lwe_dimension = match key_switching_key_material.destination_key {
            EncryptionKeyChoice::Big => dest_server_key.bootstrapping_key.output_lwe_dimension(),
            EncryptionKeyChoice::Small => dest_server_key.bootstrapping_key.input_lwe_dimension(),
        };

        assert_eq!(
            dst_lwe_dimension,
            key_switching_key_material
                .key_switching_key
                .output_key_lwe_dimension(),
            "Mismatch between the destination CompressedServerKey ciphertext LweDimension ({:?}) \
            and the SeededLweKeyswitchKey output LweDimension ({:?})",
            dst_lwe_dimension,
            key_switching_key_material
                .key_switching_key
                .output_key_lwe_dimension(),
        );
        assert_eq!(
            key_switching_key_material
                .key_switching_key
                .ciphertext_modulus(),
            dest_server_key.ciphertext_modulus,
            "Mismatch between the SeededLweKeyswitchKey CiphertextModulus ({:?}) \
            and the destination CompressedServerKey CiphertextModulus ({:?})",
            key_switching_key_material
                .key_switching_key
                .ciphertext_modulus(),
            dest_server_key.ciphertext_modulus,
        );

        Self {
            key_switching_key_material,
            dest_server_key,
            src_server_key,
        }
    }
}

pub struct KeySwitchingKeyConformanceParams {
    pub keyswitch_key_conformance_params: KeyswitchKeyConformanceParams,
    pub cast_rshift: i8,
    pub destination_key: EncryptionKeyChoice,
}

impl ParameterSetConformant for KeySwitchingKeyMaterial {
    type ParameterSet = KeySwitchingKeyConformanceParams;

    fn is_conformant(&self, parameter_set: &Self::ParameterSet) -> bool {
        let Self {
            key_switching_key,
            cast_rshift,
            destination_key,
        } = self;

        key_switching_key.is_conformant(&parameter_set.keyswitch_key_conformance_params)
            && *cast_rshift == parameter_set.cast_rshift
            && *destination_key == parameter_set.destination_key
    }
}

impl ParameterSetConformant for CompressedKeySwitchingKeyMaterial {
    type ParameterSet = KeySwitchingKeyConformanceParams;

    fn is_conformant(&self, parameter_set: &Self::ParameterSet) -> bool {
        let Self {
            key_switching_key,
            cast_rshift,
            destination_key,
        } = self;

        key_switching_key.is_conformant(&parameter_set.keyswitch_key_conformance_params)
            && *cast_rshift == parameter_set.cast_rshift
            && *destination_key == parameter_set.destination_key
    }
}
